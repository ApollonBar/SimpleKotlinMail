{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to SimpleKotlinMail SimpleKotlinMail is a Kotlin Email API - coroutine based, easy to use and modern! You can use it for both clientside and serverside projects, meaning you can send and receive emails. Coroutines Send emails without blocking the current thread. Easy to use Create emails, mailers and SMTP servers with the help of intuitive Kotlin builders. Modern SimpleKotlinMail hides unnecessary and overly complicated parts of the mail protocol from you. Additionally, the API is typesafe. Links GitHub repository Get Started Follow the setup guide to get started quickly.","title":"Home"},{"location":"#welcome-to-simplekotlinmail","text":"SimpleKotlinMail is a Kotlin Email API - coroutine based, easy to use and modern! You can use it for both clientside and serverside projects, meaning you can send and receive emails.","title":"Welcome to SimpleKotlinMail"},{"location":"#coroutines","text":"Send emails without blocking the current thread.","title":"Coroutines"},{"location":"#easy-to-use","text":"Create emails, mailers and SMTP servers with the help of intuitive Kotlin builders.","title":"Easy to use"},{"location":"#modern","text":"SimpleKotlinMail hides unnecessary and overly complicated parts of the mail protocol from you. Additionally, the API is typesafe.","title":"Modern"},{"location":"#links","text":"GitHub repository","title":"Links"},{"location":"#get-started","text":"Follow the setup guide to get started quickly.","title":"Get Started"},{"location":"client/","text":"Client Mailer A mailer instance is connected to an SMTP server capable of sending emails (e.g. Postfix , paid services or Gmail). For a list of free SMTP servers have look into this list by mailtrap . If you want to configure a send-only postfix server, read this tutorial . Create a Mailer val mailer = mailerBuilder(host = \"your_hostname\", port = 25) Set the global default Mailer The default mailer will be used for sending emails if no specific mailer is passed as a parameter . MailerManager.defaultMailer = mailer Shutdown all Mailers The mailer instances keep your program alive. In order to exit your program safely, you have to shut down the mailer instances. MailerManager.shutdownMailers() Send emails Easily send your previously built emails . Using coroutines (Asynchronously) This approach allows you to send emails without blocking the current thread. These methods only work within a CoroutineScope . email.send() // using the defult Mailer instance // or email.send(mailer) With the suspending send function you can specify two suspending callbacks: email.send( onException = { it.printStackTrace() }, onSuccess = { println(\"I just sent an email!\") } ) Suspend until completion email.send(awaitCompletion = true) Synchronously If you need to send your emails synchronously for some reason, you do that. This function does not provide any callbacks like onSuccess or onException - instead it will throw an exception if the action fails, otherwise (on success) it will just pass. email.sendSync() // using the defult Mailer instance // or email.sendSync(mailer)","title":"Client"},{"location":"client/#client","text":"","title":"Client"},{"location":"client/#mailer","text":"A mailer instance is connected to an SMTP server capable of sending emails (e.g. Postfix , paid services or Gmail). For a list of free SMTP servers have look into this list by mailtrap . If you want to configure a send-only postfix server, read this tutorial .","title":"Mailer"},{"location":"client/#create-a-mailer","text":"val mailer = mailerBuilder(host = \"your_hostname\", port = 25)","title":"Create a Mailer"},{"location":"client/#set-the-global-default-mailer","text":"The default mailer will be used for sending emails if no specific mailer is passed as a parameter . MailerManager.defaultMailer = mailer","title":"Set the global default Mailer"},{"location":"client/#shutdown-all-mailers","text":"The mailer instances keep your program alive. In order to exit your program safely, you have to shut down the mailer instances. MailerManager.shutdownMailers()","title":"Shutdown all Mailers"},{"location":"client/#send-emails","text":"Easily send your previously built emails .","title":"Send emails"},{"location":"client/#using-coroutines-asynchronously","text":"This approach allows you to send emails without blocking the current thread. These methods only work within a CoroutineScope . email.send() // using the defult Mailer instance // or email.send(mailer) With the suspending send function you can specify two suspending callbacks: email.send( onException = { it.printStackTrace() }, onSuccess = { println(\"I just sent an email!\") } )","title":"Using coroutines (Asynchronously)"},{"location":"client/#suspend-until-completion","text":"email.send(awaitCompletion = true)","title":"Suspend until completion"},{"location":"client/#synchronously","text":"If you need to send your emails synchronously for some reason, you do that. This function does not provide any callbacks like onSuccess or onException - instead it will throw an exception if the action fails, otherwise (on success) it will just pass. email.sendSync() // using the defult Mailer instance // or email.sendSync(mailer)","title":"Synchronously"},{"location":"core/","text":"Email API Create an email You can create an email using the emailBuilder function. Inside an email builder you set everything you need. val email = emailBuilder { from(\"foo@bar.com\") to(\"info@example.org\") withSubject(\"Important question\") withPlainText(\"Hey, how are you today?\") // and much more } A built email object is immutable. Send that email Go to the client page . Copy an email If you don't want to start blank with your email builder, you can copy another email and change it to your liking. val copiedEmail = email.copy { // modify the email } Forward an email val forwardEmail = email.forward(from = \"forwardaddress@example.org\") { prependText(\"This is a forwarded message.\") } Reply to an email val replyEmail = email.reply(from = \"replyaddress@example.org\", toAll = false) { prependText(\"This is a reply message.\") }","title":"Email API"},{"location":"core/#email-api","text":"","title":"Email API"},{"location":"core/#create-an-email","text":"You can create an email using the emailBuilder function. Inside an email builder you set everything you need. val email = emailBuilder { from(\"foo@bar.com\") to(\"info@example.org\") withSubject(\"Important question\") withPlainText(\"Hey, how are you today?\") // and much more } A built email object is immutable.","title":"Create an email"},{"location":"core/#send-that-email","text":"Go to the client page .","title":"Send that email"},{"location":"core/#copy-an-email","text":"If you don't want to start blank with your email builder, you can copy another email and change it to your liking. val copiedEmail = email.copy { // modify the email }","title":"Copy an email"},{"location":"core/#forward-an-email","text":"val forwardEmail = email.forward(from = \"forwardaddress@example.org\") { prependText(\"This is a forwarded message.\") }","title":"Forward an email"},{"location":"core/#reply-to-an-email","text":"val replyEmail = email.reply(from = \"replyaddress@example.org\", toAll = false) { prependText(\"This is a reply message.\") }","title":"Reply to an email"},{"location":"html/","text":"HTML SimpleKotlinMail provides a convenient way for setting the HTMl content of a message. Instead of just passing in the HTML text, you can use the HTML DSL of kotlinx.html to create the HTML content. Set HTML content Inside your email builder, use the withHTML function. emailBuilder { withHTML { body { h1 { +\"Really important question:\" } p { +\"Hey, how are you today?\" } } } } What are the advantages of using kotlinx.html? In the above example, there isn't any real advantage apart from the better readability. But as soon as you want to customize the messages, for example for a specific user, kotlinx.html shows its full power. Let's say that we want to greet the user with his name. Additionally, we want to list the items he bought: val username = \"foo\" val itemsBought = listOf(\"banana\", \"apple\") emailBuilder { withHTML { body { h1 { +\"We have received your order.\" } p { +\"Thanks for shopping with us $username!\" } p { +\"You have bought the following items:\" } ul { for (item in itemsBought) li { +item } } } } } Here kotlinx.html allows us to use the existing data we have (username and itemsBought) without the need for an additional templating language.","title":"Kotlin HTML DSL"},{"location":"html/#html","text":"SimpleKotlinMail provides a convenient way for setting the HTMl content of a message. Instead of just passing in the HTML text, you can use the HTML DSL of kotlinx.html to create the HTML content.","title":"HTML"},{"location":"html/#set-html-content","text":"Inside your email builder, use the withHTML function. emailBuilder { withHTML { body { h1 { +\"Really important question:\" } p { +\"Hey, how are you today?\" } } } }","title":"Set HTML content"},{"location":"html/#what-are-the-advantages-of-using-kotlinxhtml","text":"In the above example, there isn't any real advantage apart from the better readability. But as soon as you want to customize the messages, for example for a specific user, kotlinx.html shows its full power. Let's say that we want to greet the user with his name. Additionally, we want to list the items he bought: val username = \"foo\" val itemsBought = listOf(\"banana\", \"apple\") emailBuilder { withHTML { body { h1 { +\"We have received your order.\" } p { +\"Thanks for shopping with us $username!\" } p { +\"You have bought the following items:\" } ul { for (item in itemsBought) li { +item } } } } } Here kotlinx.html allows us to use the existing data we have (username and itemsBought) without the need for an additional templating language.","title":"What are the advantages of using kotlinx.html?"},{"location":"server/","text":"SMTP Server This SMTP server can be used to receive emails. Setup To set up a new SMTP server you can use the smtpServer function. More advanced setup: val smtpServer = smtpServer(port = 25) { // access the SMTP server builder in here (more information below) } Now you can start the SMTPServer // keep the current thread alive (non-blocking) smtpServer.start(keepAlive = true) // or don't keep the current thread alive smtpServer.start(keepAlive = false) It is good practice stopping the SMTPServer smtpServer.stop() The following code samples all are inside an SMTP server builder. Optional Configuration maxRecipients The maximum amount of recipients the server accepts per message. maxRecipients = 4000 // (default is 1000) maxConnections The maximum amount of connections the server allows at once. maxConnections = 2000 // (default is 1000) prefferedMaxMessageSize The maximum size of a message. This won't be enforced, this is just an information for the connected client. prefferedMaxMessageSize = 8000 // (default is null) connectionTimeout The timeout for waiting for data on a connection. connectionTimeout = 2 to TimeUnit.MINUTES // (default is 1 minute) TLS (Secure connections) Go to the dedicated TLS page for more details. Listeners With listeners, you can receive and process emails . Mail (easiest) Listen to the DATA command (called last, therefore has the most information): mailListener { // get envelope data it.envelopeFrom it.recipients // get the email it.email // optional response it.respondText(\"OK message received\") // if the client sent too much data it.tooMuchData() } Earlier available commands are: From Listen to the MAIL FROM command (called first, can only be called once): fromListener { // get the envelope from it.envelopeFrom } Recipients Listen to the RCPT TO command (can be called multiple times): recipientListener { // current envelope data it.envelopeFrom it.currentRecipients // all recipients known so far (including the one responsible for this call) // get the recipient responsible for this call it.recipient } Reject Connections You can reject connections after receiving any command. Both functions have parameters for a custom reponse and status code. // reject the connection it.reject() // drop the connection it.dropConnection() Common You can do the following inside every callback: // get the MessageContext it.context // get the session it.context.session // example usage of session it.context.session?.socket is SSLSocket","title":"Server"},{"location":"server/#smtp-server","text":"This SMTP server can be used to receive emails.","title":"SMTP Server"},{"location":"server/#setup","text":"To set up a new SMTP server you can use the smtpServer function. More advanced setup: val smtpServer = smtpServer(port = 25) { // access the SMTP server builder in here (more information below) } Now you can start the SMTPServer // keep the current thread alive (non-blocking) smtpServer.start(keepAlive = true) // or don't keep the current thread alive smtpServer.start(keepAlive = false) It is good practice stopping the SMTPServer smtpServer.stop() The following code samples all are inside an SMTP server builder.","title":"Setup"},{"location":"server/#optional-configuration","text":"maxRecipients The maximum amount of recipients the server accepts per message. maxRecipients = 4000 // (default is 1000) maxConnections The maximum amount of connections the server allows at once. maxConnections = 2000 // (default is 1000) prefferedMaxMessageSize The maximum size of a message. This won't be enforced, this is just an information for the connected client. prefferedMaxMessageSize = 8000 // (default is null) connectionTimeout The timeout for waiting for data on a connection. connectionTimeout = 2 to TimeUnit.MINUTES // (default is 1 minute)","title":"Optional Configuration"},{"location":"server/#tls-secure-connections","text":"Go to the dedicated TLS page for more details.","title":"TLS (Secure connections)"},{"location":"server/#listeners","text":"With listeners, you can receive and process emails .","title":"Listeners"},{"location":"server/#mail-easiest","text":"Listen to the DATA command (called last, therefore has the most information): mailListener { // get envelope data it.envelopeFrom it.recipients // get the email it.email // optional response it.respondText(\"OK message received\") // if the client sent too much data it.tooMuchData() } Earlier available commands are:","title":"Mail (easiest)"},{"location":"server/#from","text":"Listen to the MAIL FROM command (called first, can only be called once): fromListener { // get the envelope from it.envelopeFrom }","title":"From"},{"location":"server/#recipients","text":"Listen to the RCPT TO command (can be called multiple times): recipientListener { // current envelope data it.envelopeFrom it.currentRecipients // all recipients known so far (including the one responsible for this call) // get the recipient responsible for this call it.recipient }","title":"Recipients"},{"location":"server/#reject-connections","text":"You can reject connections after receiving any command. Both functions have parameters for a custom reponse and status code. // reject the connection it.reject() // drop the connection it.dropConnection()","title":"Reject Connections"},{"location":"server/#common","text":"You can do the following inside every callback: // get the MessageContext it.context // get the session it.context.session // example usage of session it.context.session?.socket is SSLSocket","title":"Common"},{"location":"setup_gradle/","text":"Setup Repository SimpleKotlinMail is available on jcenter. repositories { jcenter() } Dependencies Kotlin DSL dependencies { implementation(\"net.axay:MODULE:VERSION\") } or Groovy DSL dependencies { implementation 'net.axay:MODULE:VERSION' } Replace : VERSION with the version you wish to use (you can find the latest version on github ) MODULE with the names of the following modules: Modules simplekotlinmail-core (required) simplekotlinmail-client if you want to send emails simplekotlinmail-server if you want to receive emails simplekotlinmail-html if you want to use kotlinx.html inside your email builders JVM Version To be able to use the inline functions of the API, you have to configure the JVM version (if you have not done that already). tasks.withType<KotlinCompile> { kotlinOptions.jvmTarget = jvmVersionString // <- e.g. 11 }","title":"Setup using Gradle"},{"location":"setup_gradle/#setup","text":"","title":"Setup"},{"location":"setup_gradle/#repository","text":"SimpleKotlinMail is available on jcenter. repositories { jcenter() }","title":"Repository"},{"location":"setup_gradle/#dependencies","text":"Kotlin DSL dependencies { implementation(\"net.axay:MODULE:VERSION\") } or Groovy DSL dependencies { implementation 'net.axay:MODULE:VERSION' } Replace : VERSION with the version you wish to use (you can find the latest version on github ) MODULE with the names of the following modules:","title":"Dependencies"},{"location":"setup_gradle/#modules","text":"simplekotlinmail-core (required) simplekotlinmail-client if you want to send emails simplekotlinmail-server if you want to receive emails simplekotlinmail-html if you want to use kotlinx.html inside your email builders","title":"Modules"},{"location":"setup_gradle/#jvm-version","text":"To be able to use the inline functions of the API, you have to configure the JVM version (if you have not done that already). tasks.withType<KotlinCompile> { kotlinOptions.jvmTarget = jvmVersionString // <- e.g. 11 }","title":"JVM Version"},{"location":"setup_maven/","text":"Setup (Maven) Just use Gradle - its better.","title":"Setup using Maven"},{"location":"setup_maven/#setup-maven","text":"Just use Gradle - its better.","title":"Setup (Maven)"},{"location":"tls/","text":"TLS TLS ( Transport Layer Security ) allows you to secure the Simple Mail Transfer Protocol. TLSContext (SSLContext) SimpleKotlinMail provides a utility function allowing you to easily create a new TLSContext (actually an SSLContext). val tlsContext = TLSContext( File(\"path/to/keystore\"), keyStorePassphrase = \"passphrase\", File(\"path/to/truststore\"), trustStorePassphrase = \"passphrase\" ) If you need a keystore and truststore for testing purposes , you can download both from the OpenJDK repository . Secure the SMTP server Use the setupTLS function inside an SMTP server builder. smtpServer { setupTLS(tlsContext) } Currently, TLSv1.3 and TLSv1.2 are enabled by default, but you can change that (example below). or if you need more options setupTLS( tlsContext, requireTLS = true, protocolVersions = listOf(TLSVersions.TLS_1_3), requireClientAuth = true ) { // configure the SSLSocket to your liking } Secure the Mailer Inside a mailer builder, you can set the transport strategy: mailerBuilder { // STARTTLS withTransportStrategy(TransportStrategy.SMTP_TLS) // or complete TLS encryption withTransportStrategy(TransportStrategy.SMTPS) }","title":"TLS"},{"location":"tls/#tls","text":"TLS ( Transport Layer Security ) allows you to secure the Simple Mail Transfer Protocol.","title":"TLS"},{"location":"tls/#tlscontext-sslcontext","text":"SimpleKotlinMail provides a utility function allowing you to easily create a new TLSContext (actually an SSLContext). val tlsContext = TLSContext( File(\"path/to/keystore\"), keyStorePassphrase = \"passphrase\", File(\"path/to/truststore\"), trustStorePassphrase = \"passphrase\" ) If you need a keystore and truststore for testing purposes , you can download both from the OpenJDK repository .","title":"TLSContext (SSLContext)"},{"location":"tls/#secure-the-smtp-server","text":"Use the setupTLS function inside an SMTP server builder. smtpServer { setupTLS(tlsContext) } Currently, TLSv1.3 and TLSv1.2 are enabled by default, but you can change that (example below). or if you need more options setupTLS( tlsContext, requireTLS = true, protocolVersions = listOf(TLSVersions.TLS_1_3), requireClientAuth = true ) { // configure the SSLSocket to your liking }","title":"Secure the SMTP server"},{"location":"tls/#secure-the-mailer","text":"Inside a mailer builder, you can set the transport strategy: mailerBuilder { // STARTTLS withTransportStrategy(TransportStrategy.SMTP_TLS) // or complete TLS encryption withTransportStrategy(TransportStrategy.SMTPS) }","title":"Secure the Mailer"}]}